{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["import * as utils from '@iobroker/adapter-core';\nimport puppeteer, { Page, Browser, ScreenshotOptions, ScreenshotClip, Viewport } from 'puppeteer';\nimport { isObject } from './lib/tools';\nimport { normalize, resolve, sep as pathSeparator } from 'path';\n\nclass PuppeteerAdapter extends utils.Adapter {\n    private browser: Browser | undefined;\n    public constructor(options: Partial<utils.AdapterOptions> = {}) {\n        super({ ...options, name: 'puppeteer' });\n\n        this.on('ready', this.onReady.bind(this));\n        this.on('stateChange', this.onStateChange.bind(this));\n        this.on('unload', this.onUnload.bind(this));\n        this.on('message', this.onMessage.bind(this));\n    }\n\n    /**\n     * Is called when databases are connected and adapter received configuration.\n     */\n    private async onReady(): Promise<void> {\n        this.browser = await puppeteer.launch({ headless: true, defaultViewport: null });\n        this.subscribeStates('url');\n        this.log.info('Ready to take screenshots');\n    }\n\n    /**\n     * Is called when adapter shuts down - callback has to be called under any circumstances!\n     */\n    private async onUnload(callback: () => void): Promise<void> {\n        try {\n            if (this.browser) {\n                this.log.info('Closing browser');\n                await this.browser.close();\n                this.browser = undefined;\n            }\n            callback();\n        } catch {\n            callback();\n        }\n    }\n\n    /**\n     * Is called when message received\n     */\n    private async onMessage(obj: ioBroker.Message): Promise<void> {\n        if (!this.browser) {\n            // unload called\n            return;\n        }\n\n        this.log.debug(`Message: ${JSON.stringify(obj)}`);\n\n        if (obj.command === 'screenshot') {\n            let url: string;\n            let options: Record<string, any>;\n\n            if (typeof obj.message === 'string') {\n                url = obj.message;\n                options = {};\n            } else {\n                url = obj.message.url;\n                options = obj.message;\n                delete options.url;\n            }\n\n            const { waitMethod, waitParameter } = PuppeteerAdapter.extractWaitOptionFromMessage(options);\n            const { storagePath } = PuppeteerAdapter.extractIoBrokerOptionsFromMessage(options);\n            const viewport = PuppeteerAdapter.extractViewportOptionsFromMessage(options);\n\n            try {\n                if (options.path) {\n                    this.validatePath(options.path);\n                }\n\n                const page = await this.browser.newPage();\n\n                if (viewport) {\n                    await page.setViewport(viewport);\n                }\n\n                await page.goto(url, { waitUntil: 'networkidle2' });\n\n                // if wait options given, await them\n                if (waitMethod && waitMethod in page) {\n                    await (page as any)[waitMethod](waitParameter);\n                }\n\n                const img = await page.screenshot(options);\n                if (storagePath) {\n                    this.log.debug(`Write file to \"${storagePath}\"`);\n                    await this.writeFileAsync('0_userdata.0', storagePath, img);\n                }\n\n                this.sendTo(obj.from, obj.command, { result: img }, obj.callback);\n            } catch (e) {\n                this.log.error(`Could not take screenshot of \"${url}\": ${e.message}`);\n                this.sendTo(obj.from, obj.command, { error: e }, obj.callback);\n            }\n        } else {\n            this.log.error(`Unsupported message command: ${obj.command}`);\n            this.sendTo(\n                obj.from,\n                obj.command,\n                { error: new Error(`Unsupported message command: ${obj.command}`) },\n                obj.callback\n            );\n        }\n    }\n\n    /**\n     * Is called if a subscribed state changes\n     */\n    private async onStateChange(id: string, state: ioBroker.State | null | undefined): Promise<void> {\n        if (!this.browser) {\n            // unload called\n            return;\n        }\n\n        // user wants to perform a screenshot\n        if (state && state.val && !state.ack) {\n            const options: ScreenshotOptions = await this.gatherScreenshotOptions();\n\n            if (!options.path) {\n                this.log.error('Please specify a filename before taking a screenshot');\n                return;\n            }\n\n            try {\n                this.validatePath(options.path);\n            } catch (e) {\n                this.log.error(`Cannot take screenshot: ${e.message}`);\n                return;\n            }\n\n            this.log.debug(`Screenshot options: ${JSON.stringify(options)}`);\n            this.log.info(`Taking screenshot of \"${state.val}\"`);\n\n            try {\n                const page = await this.browser.newPage();\n                await page.goto(state.val as string, { waitUntil: 'networkidle2' });\n\n                await this.waitForConditions(page);\n\n                await page.screenshot(options);\n\n                // set ack true, to inform about screenshot creation\n                this.log.info('Screenshot sucessfully saved');\n                await this.setStateAsync(id, state.val, true);\n                await page.close();\n            } catch (e) {\n                this.log.error(`Could not take screenshot of \"${state.val}\": ${e.message}`);\n            }\n        }\n    }\n\n    /**\n     * Determines the ScreenshotOptions by the current configuration states\n     */\n    private async gatherScreenshotOptions(): Promise<ScreenshotOptions> {\n        const options: ScreenshotOptions = {};\n\n        // get the path\n        const filenameState = await this.getStateAsync('filename');\n        if (filenameState && filenameState.val) {\n            options.path = filenameState.val as string;\n        }\n\n        // check fullPage flag\n        const fullPageState = await this.getStateAsync('fullPage');\n        if (fullPageState) {\n            options.fullPage = !!fullPageState.val;\n        }\n\n        if (!options.fullPage) {\n            const clipOptions: ScreenshotClip | void = await this.gatherScreenshotClipOptions();\n\n            if (clipOptions) {\n                options.clip = clipOptions;\n            }\n        } else {\n            this.log.debug('Ingoring clip options, because full page is desired');\n        }\n\n        return options;\n    }\n\n    /**\n     * Determines the ScreenshotClipOptions by the current configuration states\n     */\n    private async gatherScreenshotClipOptions(): Promise<ScreenshotClip | void> {\n        const options: Partial<ScreenshotClip> = {};\n\n        const clipAttributes = {\n            clipLeft: 'x',\n            clipTop: 'y',\n            clipHeight: 'height',\n            clipWidth: 'width'\n        } as const;\n\n        for (const [id, attributeName] of Object.entries(clipAttributes)) {\n            const clipAttributeState = await this.getStateAsync(id);\n            if (clipAttributeState && typeof clipAttributeState.val === 'number') {\n                options[attributeName] = clipAttributeState.val;\n            } else {\n                this.log.debug(`Ignoring clip, because \"${id}\" is not configured`);\n                return;\n            }\n        }\n\n        return options as ScreenshotClip;\n    }\n\n    /**\n     * Validates that the given path is valid to save a screenshot too, prevents node_modules and dataDir\n     * @param path path to check\n     */\n    private validatePath(path: string): void {\n        path = resolve(normalize(path));\n        this.log.debug(`Checking path \"${path}\"`);\n\n        if (path.startsWith(utils.getAbsoluteDefaultDataDir())) {\n            throw new Error('Screenshots cannot be stored inside the ioBroker storage');\n        }\n\n        if (path.includes(`${pathSeparator}node_modules${pathSeparator}`)) {\n            throw new Error('Screenshots cannot be stored inside a node_modules folder');\n        }\n    }\n\n    /**\n     * Waits until the user configured conditions are fullfilled\n     *\n     * @param page active page object\n     */\n    private async waitForConditions(page: Page): Promise<void> {\n        // selector has highest priority\n        const selector = (await this.getStateAsync('waitForSelector'))?.val;\n        if (selector && typeof selector === 'string') {\n            this.log.debug(`Waiting for selector \"${selector}\"`);\n            await page.waitForSelector(selector);\n            return;\n        }\n\n        const renderTimeMs = (await this.getStateAsync('renderTime'))?.val;\n        if (renderTimeMs && typeof renderTimeMs === 'number') {\n            this.log.debug(`Waiting for timeout \"${renderTimeMs}\" ms`);\n            await page.waitForTimeout(renderTimeMs);\n            return;\n        }\n    }\n\n    /**\n     * Extracts the ioBroker specific options from the message\n     *\n     * @param options obj.message part of a message passed by user\n     */\n    private static extractIoBrokerOptionsFromMessage(options: Record<string, any>): {\n        storagePath: string | undefined;\n    } {\n        let storagePath: string | undefined;\n        if (typeof options.ioBrokerOptions?.storagePath === 'string') {\n            storagePath = options.ioBrokerOptions.storagePath;\n        }\n\n        delete options.ioBrokerOptions;\n        return { storagePath };\n    }\n\n    /**\n     * Extracts the viewport specific options from the message\n     *\n     * @param options obj.message part of a message passed by user\n     */\n    private static extractViewportOptionsFromMessage(options: Record<string, any>): Viewport | undefined {\n        let viewportOptions: Viewport | undefined;\n        if (\n            isObject(options.viewportOptions) &&\n            typeof options.viewportOptions.width === 'number' &&\n            typeof options.viewportOptions.height === 'number'\n        ) {\n            viewportOptions = options.viewportOptions as Viewport;\n        }\n\n        delete options.viewportOptions;\n        return viewportOptions;\n    }\n\n    /**\n     * Extracts the waitOption from a message\n     *\n     * @param options obj.message part of a message passed by user\n     */\n    private static extractWaitOptionFromMessage(options: Record<string, any>): {\n        waitMethod: string | undefined;\n        waitParameter: unknown;\n    } {\n        let waitMethod: string | undefined;\n        let waitParameter: unknown;\n\n        if ('waitOption' in options) {\n            if (isObject(options.waitOption)) {\n                waitMethod = Object.keys(options.waitOption)[0];\n                waitParameter = Object.values(options.waitOption)[0];\n            }\n            delete options.waitOption;\n        }\n\n        return { waitMethod, waitParameter };\n    }\n}\n\nif (require.main !== module) {\n    // Export the constructor in compact mode\n    module.exports = (options: Partial<utils.AdapterOptions> | undefined) => new PuppeteerAdapter(options);\n} else {\n    // otherwise start the instance directly\n    (() => new PuppeteerAdapter())();\n}\n"],
  "mappings": "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",
  "names": []
}
